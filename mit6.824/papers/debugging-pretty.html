<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/assets/images/favicon.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/assets/images/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="/assets/images/favicon-16x16.png"
    />
    <title>Debugging by Pretty Printing</title>
    <meta name="description" content="Debugging distributed systems is a hard task. We can make this task easier by making use of good logging practices and taking advantage of Terminal User Interface tools, making parsing distributed logs effortless." />
    <link rel="stylesheet" href="/assets/css/simple.css" />
    <link rel="stylesheet" href="/assets/css/syntax.css" />
  </head>
  <body>
    <header>
      <h1>Debugging by Pretty Printing</h1>
      <p>Debugging distributed systems is a hard task. We can make this task easier by making use of good logging practices and taking advantage of Terminal User Interface tools, making parsing distributed logs effortless.</p>

      <nav>
  
  <a href="/">Blog</a>
  
  <a href="https://josejg.com">About</a>
  
  <a href="/feed.xml">RSS</a>
  
  <!-- <a target="_blank" class="icon-url" title="RSS" href="/assets/images/rss.svg"> -->
  <!--   <img class="icon" src="/assets/images/rss.svg" alt="RSS" /> -->
  <!-- </a> -->
</nav>

    </header>

    <main><p>15 Mar 2021</p>

<p>This semester I’m a Teaching Assistant for MIT’s <a href="https://pdos.csail.mit.edu/6.824/">6.824 Distributed Systems</a> class. The class requires students to iteratively implement Raft, a distributed consensus protocol. This is a very challenging task, as despite Raft’s claim to fame as an <em>“easier to understand Paxos”</em>, Raft is a complex distributed system that is quite hard to get right, even after several (or many) attempts.
When I took 6.824, I noticed that the bottleneck for finishing the labs never was doing the bulk of the required implementation for the corresponding lab. Overall, what consumed most of my time was getting the failed runs and parsing through the logs to understand how the system failed and what went wrong.</p>

<p>In this post, I won’t go over common pitfalls or how a Raft implementation usually goes wrong, if you are interested in that, check out the fantastic <a href="https://thesquareplanet.com/blog/students-guide-to-raft/">Students’ Guide to Raft</a>. What I’ll cover is how to write tools to make your life as a distributed systems debugger easier. We will see how to build these terminal-based tools from the ground up, ending with a debugging suite that will make you more efficient at detecting, understanding and fixing bugs for the 6.824 labs. All the labs in 6.824 are debugged in the same way, so it’s probably a good idea to invest some time in making collecting and parsing logs less laborious.</p>

<h2 id="debugging-distributed-code-hits-different">Debugging distributed code hits different</h2>

<p>Debugging distributed systems is a task many students have not dealt with before taking 6.824, and it’s fundamentally different from other forms of debugging. There are no easily accessible debuggers like <code class="language-html highlighter-rouge">gdb</code> or <code class="language-html highlighter-rouge">pdb</code> that let you run your code step by step. And traditional <em>printf debugging</em> also falls short since there can be a large amount of routines running (and thus, printing) in parallel.
In traditional systems, debugging via print statements is fairly straightforward, since there is often a single thread of execution and one can quickly reason about what is going on.</p>

<p>With distributed systems like the ones in the 6.824 labs, there are N machines and each of them is concurrently executing several threads. For instance, in the Raft labs there are N raft peers executing in parallel as if they were in separate machines. For each one of these peers there will be multiple goroutines executing in parallel (commonly one or two timers, an applier and some amount of RPC and RPC reply handlers), leading to large amounts of concurrency. While adding print statements is easy, parsing through them can be quite tricky, specially as the complexity of the labs slowly builds up week after week.
All that said, going through your logs to identify the faults in your logic is the best bang for your <del>buck</del> pset hour. Staring at your code or repeatedly tweaking different parts might help in the short term, but hard bugs will require a more careful analysis.</p>

<p>Moreover, in a system like Raft not only there are multiple threads printing output at once, but they will be printing about very heterogeneous events such as: timer resets, log operations, elections, crash recovery or communication with the replicated state machine. Crucially, different types of events will occur with different frequencies, which can lead to overly verbose logs if they are not trimmed in some way.</p>

<p>Therefore, we would ideally like to know <strong>who</strong> is printing each line and <strong>what topic</strong> the message is related to. Our goal is to design a way of encoding those pieces of information visually. TL;DR: We will make Go print a boring log with a specific format and then make use of the <a href="https://github.com/willmcgugan/rich">Rich</a> Python library to abstract away the ugly complexity of printing beautifully formatted terminal output.</p>

<h3 id="the-go-side">The Go side</h3>

<p>While most of the tooling will be done using Python scripts, there needs to be some cooperation from the Go side to ensure that we feed the information to downstream scripts in a way that is easy to parse.</p>

<p><strong>Toggling the output verbosity</strong>.
A minor quality of life improvement that I implemented is the ability to toggle log verbosity without having to edit go code at all. Later on, this will also make it easier for our automated script runner to control verbosity.
Since the 6.824 tests use <code class="language-html highlighter-rouge">go test</code>, we can’t use command line arguments directly. However, what we can use are <a href="https://www.wikiwand.com/en/Environment_variable">environment variables</a>. The following piece of code will access the <code class="language-html highlighter-rouge">VERBOSE</code> environment variable to decide whether verbose logs are needed.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c">// Retrieve the verbosity level from an environment variable</span>
<span class="k">func</span> <span class="n">getVerbosity</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="n">v</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Getenv</span><span class="p">(</span><span class="s">"VERBOSE"</span><span class="p">)</span>
	<span class="n">level</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="s">""</span> <span class="p">{</span>
		<span class="k">var</span> <span class="n">err</span> <span class="kt">error</span>
		<span class="n">level</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">Atoi</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Fatalf</span><span class="p">(</span><span class="s">"Invalid verbosity %v"</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">level</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Logging with topics</strong>. I decided to fundamentally alter my printf function of choice to accept as a first argument a <em>topic</em> that encodes what category the message belongs to. This first argument is in essence a string, but to make code easier to refactor (and because I dislike typing quotes), I declared the topic as constants. The topics relate to different parts of the implementation, and by making them fine grained we will able to filter, search and even highlight them with different colors.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">type</span> <span class="n">logTopic</span> <span class="kt">string</span>
<span class="k">const</span> <span class="p">(</span>
	<span class="n">dClient</span>  <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"CLNT"</span>
	<span class="n">dCommit</span>  <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"CMIT"</span>
	<span class="n">dDrop</span>    <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"DROP"</span>
	<span class="n">dError</span>   <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"ERRO"</span>
	<span class="n">dInfo</span>    <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"INFO"</span>
	<span class="n">dLeader</span>  <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"LEAD"</span>
	<span class="n">dLog</span>     <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"LOG1"</span>
	<span class="n">dLog2</span>    <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"LOG2"</span>
	<span class="n">dPersist</span> <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"PERS"</span>
	<span class="n">dSnap</span>    <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"SNAP"</span>
	<span class="n">dTerm</span>    <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"TERM"</span>
	<span class="n">dTest</span>    <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"TEST"</span>
	<span class="n">dTimer</span>   <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"TIMR"</span>
	<span class="n">dTrace</span>   <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"TRCE"</span>
	<span class="n">dVote</span>    <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"VOTE"</span>
	<span class="n">dWarn</span>    <span class="n">logTopic</span> <span class="o">=</span> <span class="s">"WARN"</span>
<span class="p">)</span>
</code></pre></div></div>

<p><strong>The print function</strong>. The last moving piece on the Go side is the actual print function we will use to dump output. I called mine <code class="language-html highlighter-rouge">Debug</code> and it prints the message along with the topic and the amount of milliseconds since the start of the run. I disable all datetime logging since that information is quite redundant (all tests must pass in at most a couple of minutes). Moreover, printing just the milliseconds renders useful when checking that timer-related events happen with the expected frequency.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">var</span> <span class="n">debugStart</span> <span class="n">time</span><span class="o">.</span><span class="n">Time</span>
<span class="k">var</span> <span class="n">debugVerbosity</span> <span class="kt">int</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">debugVerbosity</span> <span class="o">=</span> <span class="n">getVerbosity</span><span class="p">()</span>
	<span class="n">debugStart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span>

	<span class="n">log</span><span class="o">.</span><span class="n">SetFlags</span><span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">Flags</span><span class="p">()</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="n">log</span><span class="o">.</span><span class="n">Ldate</span> <span class="o">|</span> <span class="n">log</span><span class="o">.</span><span class="n">Ltime</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Debug</span><span class="p">(</span><span class="n">topic</span> <span class="n">logTopic</span><span class="p">,</span> <span class="n">format</span> <span class="kt">string</span><span class="p">,</span> <span class="n">a</span> <span class="o">...</span><span class="k">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">debug</span> <span class="o">&gt;=</span> <span class="m">1</span> <span class="p">{</span>
		<span class="n">time</span> <span class="o">:=</span> <span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">debugStart</span><span class="p">)</span><span class="o">.</span><span class="n">Microseconds</span><span class="p">()</span>
		<span class="n">time</span> <span class="o">/=</span> <span class="m">100</span>
		<span class="n">prefix</span> <span class="o">:=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s">"%06d %v "</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="kt">string</span><span class="p">(</span><span class="n">topic</span><span class="p">))</span>
		<span class="n">format</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">format</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">a</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A missing piece here is <strong>who</strong> is sending this message. I pass that directly as the first few characters when printing. For example</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="syntax"><code>    <span class="n">Debug</span><span class="p">(</span><span class="n">dTimer</span><span class="p">,</span> <span class="s">"S%d Leader, checking heartbeats"</span><span class="p">,</span> <span class="n">rf</span><span class="o">.</span><span class="n">me</span><span class="p">)</span>
</code></pre></div></div>

<p>So if we now run with verbosity (e.g. <code class="language-html highlighter-rouge">VERBOSE=1 go test -run TestBackup2B</code>) the output will look something like the excerpt below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>...
008258 LOG2 S2 Saved Log (-1, 0) [{&lt;nil&gt; 0}]
008256 VOTE S3 Granting Vote to S1 at T1
008258 VOTE S1 &lt;- S0 Got vote
008258 VOTE S4 Granting Vote to S1 at T1
008259 PERS S4 Saved State T:1 VF:1
008258 PERS S3 Saved State T:1 VF:1
008259 LOG2 S3 Saved Log (-1, 0) [{&lt;nil&gt; 0}]
008259 VOTE S1 &lt;- S2 Got vote
008260 LEAD S1 Achieved Majority for T1 (3), converting to Leader
008260 TIMR S1 Broadcast, reseting HBT
008260 LOG1 S1 -&gt; S0 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []
008260 LOG1 S1 -&gt; S2 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []
008259 LOG2 S4 Saved Log (-1, 0) [{&lt;nil&gt; 0}]
008261 LOG1 S1 -&gt; S3 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []
008262 LOG1 S1 -&gt; S4 Sending PLI: 0 PLT: 0 N: 0 LC: 0 - []
008262 TIMR S1 Leader, checking heartbeats
008263 TIMR S0 Resetting ELT, received AppEnt T1
008263 TIMR S3 Resetting ELT, received AppEnt T1
008264 TIMR S2 Resetting ELT, received AppEnt T1
008264 LOG2 S2 LOG: (-1, 0) [{&lt;nil&gt; 0}]
...
</code></pre></div></div>

<p>So for every line, the first three columns indicate: <strong>when</strong> the event happened, <strong>what topic</strong> it’s related to and <strong>which server</strong> is printing the message. The rest is left as free form.</p>

<h3 id="prettifying-the-logs">Prettifying the Logs</h3>

<p>So far, the output logs are still looking rather bleak. They seem functional but they would be painful to toil through for hundreds of lines as you search for the sneaky bugs in your code. We will now write a log parser, filter and pretty printer in Python.</p>

<p>While Go is great language choice for the 6.824 labs, it is not as ergonomic as Python when it comes to quick and dirty scripting. A major reason why I decided to go with Python are <a href="https://github.com/willmcgugan/rich">Rich</a> and <a href="https://github.com/tiangolo/typer">Typer</a>, a couple of nifty libraries that make writing Terminal User Interface (TUI) applications a breeze.</p>

<p>Humans are visual creatures so it’s a good idea to make use of visual tools like colors or columns to encode different types of information. Reducing the time to parse who said what will drastically improve your debugging efficiency.
However, if you have ever tried pretty printing from the terminal you will probably have realized by now that it often feels like a chore and you end up writing very messy code. Here is where <a href="https://github.com/willmcgugan/rich">Rich</a> comes to the rescue.
According to their description <em>“Rich is a Python library for rich text and beautiful formatting in the terminal”</em>. If you quickly browse their docs you will probably be amazed at the multitude of features that Rich has to offer.
I won’t go into a terrible amount of detail, but I highly encourage you to check out Rich if you build terminal Python scripts that need to present structured or interactive output.</p>

<p>For our case, Rich provides an intuitive API for dealing with printing colored output and formatting text into N columns.
For instance, <code class="language-html highlighter-rouge">rich.print("[red]This is red[/red]")</code> will print that enclosed text to the terminal using <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ANSI escape codes</a>, rendering the text red. When compared to its bash equivalent of doing <code class="language-html highlighter-rouge">echo -e "\033[91mThis is red\e[0m</code> which looks more like nonsensical characters, the choice it’s obvious.</p>

<p>Using Rich’s primitives we can easily build our pretty printer for logs. The relevant snippet is below. Implementation is mostly commented, highlighting the different features of the script which include: topic filtering, topic-based colorization and column printing.
The full script can be found <a href="https://gist.github.com/JJGO/e64c0e8aedb5d464b5f79d3b12197338">here</a>. Setting up a Python environment with the required packages and adding the script to your <code class="language-html highlighter-rouge">PATH</code> is left as an exercise for the reader.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1"># [...] # Some boring imports
# Mapping from topics to colors
# See the disclaimer at the end of the post if you
# want to use all RGB colors
</span><span class="n">TOPICS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"TIMR"</span><span class="p">:</span> <span class="s">"bright_black"</span><span class="p">,</span>
    <span class="s">"VOTE"</span><span class="p">:</span> <span class="s">"bright_cyan"</span><span class="p">,</span>
    <span class="s">"LEAD"</span><span class="p">:</span> <span class="s">"yellow"</span><span class="p">,</span>
    <span class="s">"TERM"</span><span class="p">:</span> <span class="s">"green"</span><span class="p">,</span>
    <span class="s">"LOG1"</span><span class="p">:</span> <span class="s">"blue"</span><span class="p">,</span>
    <span class="s">"LOG2"</span><span class="p">:</span> <span class="s">"cyan"</span><span class="p">,</span>
    <span class="s">"CMIT"</span><span class="p">:</span> <span class="s">"magenta"</span><span class="p">,</span>
    <span class="s">"PERS"</span><span class="p">:</span> <span class="s">"white"</span><span class="p">,</span>
    <span class="s">"SNAP"</span><span class="p">:</span> <span class="s">"bright_blue"</span><span class="p">,</span>
    <span class="s">"DROP"</span><span class="p">:</span> <span class="s">"bright_red"</span><span class="p">,</span>
    <span class="s">"CLNT"</span><span class="p">:</span> <span class="s">"bright_green"</span><span class="p">,</span>
    <span class="s">"TEST"</span><span class="p">:</span> <span class="s">"bright_magenta"</span><span class="p">,</span>
    <span class="s">"INFO"</span><span class="p">:</span> <span class="s">"bright_white"</span><span class="p">,</span>
    <span class="s">"WARN"</span><span class="p">:</span> <span class="s">"bright_yellow"</span><span class="p">,</span>
    <span class="s">"ERRO"</span><span class="p">:</span> <span class="s">"red"</span><span class="p">,</span>
    <span class="s">"TRCE"</span><span class="p">:</span> <span class="s">"red"</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># [...] # Some boring command line parsing
</span>
<span class="c1"># We can take input from a stdin (pipes) or from a file
</span><span class="n">input_</span> <span class="o">=</span> <span class="nb">file</span> <span class="k">if</span> <span class="nb">file</span> <span class="k">else</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span>
<span class="c1"># Print just some topics or exclude some topics
</span><span class="k">if</span> <span class="n">just</span><span class="p">:</span>
    <span class="n">topics</span> <span class="o">=</span> <span class="n">just</span>
<span class="k">if</span> <span class="n">ignore</span><span class="p">:</span>
    <span class="n">topics</span> <span class="o">=</span> <span class="p">[</span><span class="n">lvl</span> <span class="k">for</span> <span class="n">lvl</span> <span class="ow">in</span> <span class="n">topics</span> <span class="k">if</span> <span class="n">lvl</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">ignore</span><span class="p">)]</span>

<span class="n">topics</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">topics</span><span class="p">)</span>
<span class="n">console</span> <span class="o">=</span> <span class="n">Console</span><span class="p">()</span>
<span class="n">width</span> <span class="o">=</span> <span class="n">console</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span>

<span class="n">panic</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">input_</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Assume format from Go output
</span>        <span class="n">time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[:</span><span class="mi">6</span><span class="p">])</span>
        <span class="n">topic</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">12</span><span class="p">:].</span><span class="n">strip</span><span class="p">()</span>
        <span class="c1"># To ignore some topics
</span>        <span class="k">if</span> <span class="n">topic</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">topics</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Debug() calls from the test suite aren't associated with
</span>        <span class="c1"># any particular peer. Otherwise we can treat second column
</span>        <span class="c1"># as peer id
</span>        <span class="k">if</span> <span class="n">topic</span> <span class="o">!=</span> <span class="s">"TEST"</span> <span class="ow">and</span> <span class="n">n_columns</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>

        <span class="c1"># Colorize output by using rich syntax when needed
</span>        <span class="k">if</span> <span class="n">colorize</span> <span class="ow">and</span> <span class="n">topic</span> <span class="ow">in</span> <span class="n">TOPICS</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">TOPICS</span><span class="p">[</span><span class="n">topic</span><span class="p">]</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"[</span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="s">]</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s">[/</span><span class="si">{</span><span class="n">color</span><span class="si">}</span><span class="s">]"</span>

        <span class="c1"># Single column. Always the case for debug calls in tests
</span>        <span class="k">if</span> <span class="n">n_columns</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">topic</span> <span class="o">==</span> <span class="s">"TEST"</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Multi column printing, timing is dropped to maximize horizontal
</span>        <span class="c1"># space. Heavylifting is done through rich.column.Columns object
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s">""</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_columns</span><span class="p">)]</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">""</span> <span class="o">+</span> <span class="n">msg</span>
            <span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">msg</span>
            <span class="n">col_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="n">n_columns</span><span class="p">)</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">Columns</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">col_width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                           <span class="n">equal</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="c1"># Code from tests or panics does not follow format
</span>        <span class="c1"># so we print it as is
</span>        <span class="k">if</span> <span class="n">line</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">"panic"</span><span class="p">):</span>
            <span class="n">panic</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c1"># Output from tests is usually important so add a
</span>        <span class="c1"># horizontal line with hashes to make it more obvious
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">panic</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"-"</span> <span class="o">*</span> <span class="n">console</span><span class="p">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">""</span><span class="p">)</span>
</code></pre></div></div>

<p>Armed with this script we can now put it into action</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># You can just pipe the go test output into the script</span>
<span class="nv">$ VERBOSE</span><span class="o">=</span>1 go <span class="nb">test</span> <span class="nt">-run</span> InitialElection | dslogs
<span class="c"># ... colored output will be printed</span>

<span class="c"># We can ignore verbose topics like timers or log changes</span>
<span class="nv">$ VERBOSE</span><span class="o">=</span>1 go <span class="nb">test</span> <span class="nt">-run</span> Backup | dslogs <span class="nt">-c</span> 5 <span class="nt">-i</span> TIMR,DROP,LOG2
<span class="c"># ... colored output in 5 columns</span>

<span class="c"># Dumping output to a file can be handy to iteratively</span>
<span class="c"># filter topics and when failures are hard to reproduce</span>
<span class="nv">$ VERBOSE</span><span class="o">=</span>1 go <span class="nb">test</span> <span class="nt">-run</span> Figure8Unreliable <span class="o">&gt;</span> output.log
<span class="c"># Print from a file, selecting just two topics</span>
<span class="nv">$ </span>dslogs output.log <span class="nt">-j</span> CMIT,PERS
<span class="c"># ... colored output</span>
</code></pre></div></div>

<p>Since a picture is worth a thousand words, below is a comparison between a sample run for a simple test with and without the log prettifying. The raw output looks a bit daunting to parse:</p>

<p><img src="/assets/images/debugging-raft/raw.png" alt="" /></p>

<p>After prettifying we’ve got a quite simple story:
S0 becomes candidate, S1 and S2 update terms and vote for S0. S0 converts to leader and starts sending and receiving heartbeats.</p>

<p><img src="/assets/images/debugging-raft/colored.png" alt="" /></p>

<p>Note, since some tests might produce thousands of lines of logs, it’s a good idea to use some sort of pager strategy to quickly navigate them. I am a happy <code class="language-html highlighter-rouge">tmux</code> user and that’s what how I went about it. I do have in my <code class="language-html highlighter-rouge">.tmux.conf</code> a history override (<code class="language-html highlighter-rouge">set -g history-limit 100000</code>) so I have enough scrollback. Using <code class="language-html highlighter-rouge">less</code> won’t work because it’ll mess with Rich’s ability to print colors and detect console width. You might try Rich’s <code class="language-html highlighter-rouge">console.pager()</code> context manager although from cursory exploration I had to wait until the whole output was there for pagination to start.</p>

<h3 id="capturing-rare-failures">Capturing Rare Failures</h3>

<p>We now have a wonderful tool for examining logs. However logs for failed runs are sometimes hard to come by. What I’m referring to is the fact that as you progressively fix mistakes in your distributed system implementations, bugs will become rarer and it can become frustrating when all tests pass except for a specific one that only fails every fifty or hundred runs.</p>

<p>Ideally we would like a script that does the following:</p>

<ul>
  <li>Executes N runs of a series of tests</li>
  <li>Saves failed runs for later inspection</li>
  <li>Runs tests in parallel.</li>
</ul>

<p>The first two items are actually quite easy to achieve with some simple bash scripting as the following snippet shows:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c">#!/usr/bin/env bash</span>

<span class="nb">trap</span> <span class="s1">'exit 1'</span> INT

<span class="nb">echo</span> <span class="s2">"Running test </span><span class="nv">$1</span><span class="s2"> for </span><span class="nv">$2</span><span class="s2"> iters"</span>
<span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span><span class="nb">seq </span>1 <span class="nv">$2</span><span class="si">)</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\r</span><span class="nv">$i</span><span class="s2"> / </span><span class="nv">$2</span><span class="s2">"</span>
    <span class="nv">LOG</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1_$i</span><span class="s2">.txt"</span>
    <span class="c"># Failed go test return nonzero exit codes</span>
    go <span class="nb">test</span> <span class="nt">-run</span> <span class="nv">$1</span> &amp;&gt; <span class="nv">$LOG</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">rm</span> <span class="nv">$LOG</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="s2">"Failed at iter </span><span class="nv">$i</span><span class="s2">, saving log at </span><span class="nv">$LOG</span><span class="s2">"</span>
    <span class="k">fi
done</span>
</code></pre></div></div>

<p>However, the previous script will only run one test at a time. Running tests in parallel speeds things up significantly, and it also sometimes helps by introducing more concurrency, leading to rare interleavings to happen more frequently.</p>

<p>Nevertheless, the concurrency property is significantly harder to achieve with bash scripting and this is where Python comes to the rescue once again. While Python has a quite complicated story for concurrency (specially when compared to Go), it does offer a pragmatic concurrency API through the <code class="language-html highlighter-rouge">concurrent.futures</code> module. Thus, we can run N tests in parallel, wait until one (or more) complete and assign new tests to the idle workers. Furthermore, when assigning new tasks, we can cycle through test types, as if we were running them sequentially in a cyclical way.</p>

<p>Below is a snippet with the core functionality to achieve the desired behavior using Python. I’ve stripped the CLI parsing and UI updating parts. The full <code class="language-html highlighter-rouge">dstest</code> script that I wrote can be found <a href="https://gist.github.com/JJGO/0d73540ef7cc2f066cb535156b7cbdab">here</a>. <code class="language-html highlighter-rouge">dstest --help</code> will give you an idea of how to use it, but it is up to you to modify it and tailor to your needs.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1"># [...] Some boring imports
</span>
<span class="c1"># concurrent.futures requires tasks that are encapsulated in a function
</span><span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="n">test</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">race</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
    <span class="n">test_cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s">"go"</span><span class="p">,</span> <span class="s">"test"</span><span class="p">,</span> <span class="sa">f</span><span class="s">"-run=</span><span class="si">{</span><span class="n">test</span><span class="si">}</span><span class="s">"</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">race</span><span class="p">:</span>
        <span class="n">test_cmd</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"-race"</span><span class="p">)</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">tempfile</span><span class="p">.</span><span class="n">mkstemp</span><span class="p">()</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">subprocess</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">test_cmd</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
    <span class="n">runtime</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">os</span><span class="p">.</span><span class="n">close</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">test</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">proc</span><span class="p">.</span><span class="n">returncode</span><span class="p">,</span> <span class="n">runtime</span>

<span class="c1"># [...] # Some boring command line parsing and UI setup
</span>
<span class="c1"># This will collate tests, so they run in a balanced way
</span><span class="n">tests</span> <span class="o">=</span> <span class="n">itertools</span><span class="p">.</span><span class="n">chain</span><span class="p">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">itertools</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">tests</span><span class="p">,</span> <span class="n">iterations</span><span class="p">))</span>

<span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>

    <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">completed</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>
        <span class="c1"># If there are fewer futures than workers assign them
</span>        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">workers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">itertools</span><span class="p">.</span><span class="n">islice</span><span class="p">(</span><span class="n">tests</span><span class="p">,</span> <span class="n">workers</span><span class="o">-</span><span class="n">n</span><span class="p">):</span>
                <span class="n">futures</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">executor</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">run_test</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">race</span><span class="p">))</span>

        <span class="c1"># Wait until a task completes
</span>        <span class="n">done</span><span class="p">,</span> <span class="n">not_done</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="n">futures</span><span class="p">,</span> <span class="n">return_when</span><span class="o">=</span><span class="n">FIRST_COMPLETED</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
            <span class="n">test</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">runtime</span> <span class="o">=</span> <span class="n">future</span><span class="p">.</span><span class="n">result</span><span class="p">()</span>

            <span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="n">output</span> <span class="o">/</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">test</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">completed</span><span class="si">}</span><span class="s">.log"</span><span class="p">).</span><span class="n">as_posix</span><span class="p">()</span>
            <span class="c1"># If the test failed, save the output for later analysis
</span>            <span class="k">if</span> <span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Failed test </span><span class="si">{</span><span class="n">test</span><span class="si">}</span><span class="s"> - </span><span class="si">{</span><span class="n">dest</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
                <span class="n">output</span><span class="p">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">shutil</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>

            <span class="n">os</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">completed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">futures</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">not_done</span><span class="p">)</span>
</code></pre></div></div>

<p>I dived into Rich again to get pretty looking progress bars and tables for the tests and I have to say that I’m quite happy with the result.
This is how the script looks while it’s executing, with failed tests and logs reported as they appear:</p>

<p><img src="/assets/images/debugging-raft/progress.png" alt="" /></p>

<p>Once it’s done, we get a report of how many failed runs there were and the mean runtime per test. In the example below, there seems to be a rare issue with snapshots and we now have a dozen logs to debug it.</p>

<p><img src="/assets/images/debugging-raft/table.png" alt="" /></p>

<h3 id="now-go-build-your-own">Now go build your own</h3>

<p>I hope this overview was helpful and provided the background and illustrative examples for the building blocks required to implement beautiful yet functional terminal tools for debugging distributed code. Huge props to the developers of Rich, without it, building these tools would have been an order of magnitude more time-consuming.</p>

<h3 id="disclaimer-truecolor-support">Disclaimer: Truecolor Support</h3>

<p>I do have to make a disclaimer about the color support required for the log parser script. Terminals support 8-bit colors by default in most cases. This 8-bit is for the whole color value so you get 256 colors in total.
However, most UI color palettes such as text editors, support 8 bits for each channel, adding up to a total of 24-bits per color, leading to the common 16 million colors denomination.</p>

<p>Rich has <a href="https://rich.readthedocs.io/en/latest/appendix/colors.html">names</a> for all the 8-bit colors so you can use them instead of the RGB codes I use if you stick with a 8-bit color palette.
On the other hand if you want to enable 24-bit color mode, you will want to search for <strong>truecolor</strong> support in your current tools.
A large fraction of modern terminal tools do support the wider array of colors although sometimes it has to be manually enabled. Do note that for truecolor to work you need <strong>all</strong> moving pieces to support truecolor. This will vary from setup to setup, but usually means:</p>

<ul>
  <li>Your terminal emulator, i.e. the GUI app that lets you access the terminal (usually one of Terminal.app, iTerm, GNOME Terminal, kitty, alacritty, Windows Terminal, &amp;c). Most modern terminals support truecolor but sometimes they require that you specify the <code class="language-html highlighter-rouge">TERM</code> environment variable as <code class="language-html highlighter-rouge">xterm-256color</code>.</li>
  <li>Terminal multiplexers like <code class="language-html highlighter-rouge">tmux</code> if you use one. Again, most likely supported but not the default behavior. Adding a few lines to your <code class="language-html highlighter-rouge">.tmux.conf</code> does the job.</li>
  <li>Your remote client, if you are using one. This is usually <code class="language-html highlighter-rouge">ssh</code> which in most cases should handle truecolor. If you use other options like <a href="https://mosh.org/">mosh</a>, <a href="https://eternalterminal.dev/">Eternal Terminal</a> or (<a href="https://www.putty.org/">PuTTY</a>, you’ll need to check.</li>
  <li>If your vim/neovim is looking sad with only 256 colors you might also want to consider enabling truecolor there.</li>
</ul>


<br />
</main>

    <footer>
      <p>
        © 2021 <a href="https://josejg.com">Jose Javier Gonzalez Ortiz</a>.
        Subscribe <a href="/feed.xml">via RSS</a>
      </p>
      <a href="https://512kb.club"
        ><img src="https://512kb.club/assets/images/green-team.svg"
      /></a>
    </footer>
  </body>
</html>
